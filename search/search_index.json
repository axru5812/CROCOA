{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CROCOA","text":"<p>CRoss COrrelation Alignment tool. </p> <p>Software package for using 2D crosscorrelation to align astronomical images.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>The primary requirements are astropy and scipy in order to manage the fits files and 2d correlation function. Additionally drizzlepac is also used to drizzle the frames in order to account for differing pixel grids and rotation</p> <p>The package is tested on python 3.7 and 3.10</p>"},{"location":"#installation","title":"Installation","text":"<p>begin by cloning the code into a folder of your choice  For having an editable installation activate your preferred virtualenv and run the following in the CROCOA main directory</p> <pre><code>$ python setup.py develop\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See the examples page for concrete examples of how to use the code.</p>"},{"location":"#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"#image-size","title":"Image size","text":"<p>The 2D correlation is very sensitive to the relative size of the target to the frame i.e. a small target in a large frame can give poor results. Therefore it can be useful to minimize the size of the frame considered while still makeing sure that the full target is contained.</p> <p>In cases where the alignment is very poor this can require manual correction of the coordinate system beforehand.</p>"},{"location":"#image-normalization","title":"Image normalization","text":"<p>How the image is normalized before being run through the 2D correlation can also impact the quality of the alignment. test setting the normalization keyword to different settings.</p>"},{"location":"#always-check-manually","title":"Always check manually","text":"<p>What the title says. The system is most definitely not infallible.</p>"},{"location":"apidocs/","title":"API Documentation","text":""},{"location":"apidocs/#align_single_filter","title":"<code>align_single_filter</code>","text":"<p>Function for aligning images in a single set</p> <p>Parameters:</p> Name Type Description Default <code>image_set</code> <code>ImageSet instance</code> <p>an ImageSet instance with the relevant files to be aligned</p> required <code>reference_image_index</code> <code>int</code> <p>index of the image in the image_set list that is to be used as reference for cross correlation</p> <code>0</code> <code>cleanup</code> <code>bool</code> <p>whether to cleanup the temporary folders and intermediate drizzling results</p> <code>True</code> <code>matching_config</code> <code>dict</code> <p>keyword arguments that are passed directly to match images</p> <code>{}</code> <code>perform_manual_shifts</code> <code>bool</code> <p>whether or not to apply a manual shift. This manual shift should be given to the ImageSet  during construction</p> <code>True</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def align_single_filter(image_set, reference_image_index=0, cleanup=True, matching_config={}, perform_manual_shifts=True):\n\"\"\" Function for aligning images in a single set\n    Parameters\n    ----------\n    image_set : ImageSet instance\n        an ImageSet instance with the relevant files to be aligned\n    reference_image_index : int\n        index of the image in the image_set list that is to be used as reference for cross correlation\n    cleanup : bool\n        whether to cleanup the temporary folders and intermediate drizzling results\n    matching_config : dict\n        keyword arguments that are passed directly to match images\n    perform_manual_shifts : bool\n        whether or not to apply a manual shift. This manual shift should be given to the ImageSet \n        during construction\n    \"\"\"\nif perform_manual_shifts:\nimage_set.apply_manual_shifts()\nimage_set.drizzle(individual=True)\nsource_images = image_set.drizzled_files\nreference_image = source_images[reference_image_index]\nfor i, image in source_images:\nif i == 0:\npass\nelse:\ndra, ddec = match_images(reference_image, image, **matching_config)\nimage_set.images[i].backpropagate_wcs_shift(dra, ddec)\nif cleanup:\nimage_set.clean_temp_directories()\n</code></pre>"},{"location":"apidocs/#align_multiple_filters","title":"<code>align_multiple_filters</code>","text":"<p>Function for aligning image sets between multiple filters </p> <p>Parameters:</p> Name Type Description Default <code>image_sets</code> <code>list or iterable</code> <p>list of ImageSet instances</p> required <code>reference_set_index</code> <code>int</code> <p>index of the ImageSet in the image_set list that is to be used as reference for cross correlation</p> <code>0</code> <code>cleanup</code> <code>bool</code> <p>whether to cleanup the temporary folders and intermediate drizzling results</p> <code>True</code> <code>matching_config</code> <code>dict</code> <p>keyword arguments that are passed directly to match images</p> <code>{}</code> <code>perform_manual_shifts</code> <code>bool</code> <p>whether or not to apply a manual shift. This manual shift should be given to the ImageSet  during construction</p> <code>True</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def align_multiple_filters(image_sets, reference_set_index=0, cleanup=True, matching_config={}, perform_manual_shifts=True):\n\"\"\" Function for aligning image sets between multiple filters \n    Parameters\n    ----------\n    image_sets : list or iterable\n        list of ImageSet instances\n    reference_set_index : int\n        index of the ImageSet in the image_set list that is to be used as reference for cross correlation\n    cleanup : bool\n        whether to cleanup the temporary folders and intermediate drizzling results\n    matching_config : dict\n        keyword arguments that are passed directly to match images\n    perform_manual_shifts : bool\n        whether or not to apply a manual shift. This manual shift should be given to the ImageSet \n        during construction\n    \"\"\"\nsource_images = []\nfor image_set in image_sets:\nif perform_manual_shifts:\nimage_set.apply_manual_shifts()\nimage_set.drizzle()\nsource_images.append(image_set.drizzled_files)\nreference_image = source_images[reference_set_index]\nfor i, image in source_images:\nif i == reference_set_index:\npass\nelse:\ndra, ddec = match_images(reference_image, image, **matching_config)\nimage_sets[i].backpropagate_wcs_shift(dra, ddec)\nif cleanup:\nimage_set.clean_temp_directories()\n</code></pre>"},{"location":"apidocs/#imageset","title":"ImageSet","text":"Source code in <code>crocoa/filemanagement.py</code> <pre><code>class ImageSet:\ndef __init__(\nself, file_list, filtername, drizzle_config, working_dir=\"./temp\", destination_dir=None, manual_shifts=None, verbose=False, \nfile_suffix=None\n) -&gt; None:\n\"\"\"\n        Parameters\n        ----------\n        file_list : list\n            list of string file names to be included in the image set\n        filtername : str\n            Name of the current filter - just used to create subdirectories\n        drizzle_config : dict\n            configuration dictionary for astrodrizzle\n        working_dir : str, optional\n            sets the temp directory parent name\n        destination_dir : str, optional\n            This sets the directory where the resulting files with the backpropagated wcs' are put. If None this defaults \n            to './filtername_aligned'\n        manual_shifts : dict or tuple\n            Either a dictionary mapping dra ddec shifts to individual images in the set or a tuple with a global dra and\n            ddec that should be applied to all the frames collectively\n        verbose : bool\n            whether to output drizzle resutls\n        file_suffix : str, optional\n            suffix to append to the file name(s)\n        \"\"\"\nself.images = [Image(file_name, verbose=verbose, file_suffix=file_suffix) for file_name in file_list]\nself.verbose = verbose\nself.drz_config = drizzle_config\nself.filtername = filtername\nself.drz_source_dir = Path(working_dir) / \"drz_source\" / filtername\nself.drz_target_dir = Path(working_dir) / \"drz_target\" / filtername\nself.manual_shifts = manual_shifts\n# Set up destination files\nself.destination_dir = destination_dir\nif self.destination_dir is not None:\nself.destination_dir = Path(destination_dir)\nself.destination_dir.mkdir(parents=True)\nelse:\nself.destination_dir = Path('./{}_aligned'.format(filter))\nself.destination_dir.mkdir(parents=True)\n#set up drizzle files\nself.drz_source_dir.mkdir(parents=True)\nself.drz_target_dir.mkdir(parents=True)\ndef make_all_copies(self):\n\"\"\" Create all relevant file copies\"\"\"\nself.make_target_copies()\nself.make_driz_source()\ndef make_target_copies(self):\n\"\"\" Make target file copies\"\"\"\nfor img in self.images:\nimg.make_target_copy(self.destination_dir)\ndef make_driz_source(self):\n\"\"\" Make source file copies since drizzle changes the source files it's run on\"\"\"\nself.working_source = []\nfor image in self.images:\nimage.make_working_copy(self.drz_source_dir)\nself.working_source.append(image.working_copy)\ndef drizzle(self, individual=False):\n\"\"\" Run the drizzling process\"\"\"\nself.drizzled_files = []\nif individual:\nfor image in self.working_source:\nif self.verbose:\nadriz(\ninput=[image],\noutput=str(\nself.drz_target_dir / os.path.basename(image).split(\".\")[0]\n),\n**self.drz_config\n)\nelse:\nwith suppress_stdout_stderr():\nadriz(\ninput=[image],\noutput=str(\nself.drz_target_dir / os.path.basename(image).split(\".\")[0]\n),\n**self.drz_config\n)\nself.drizzled_files.append(\nself.drz_target_dir.glob(\nos.path.basename(image).split(\".\")[0] + \"*drz*.fits\"\n)\n)\nelse:\nif self.verbose:\nadriz(\ninput=self.working_source,\noutput=str(self.drz_target_dir / self.filtername),\n**self.drz_config\n)\nelse:\nwith suppress_stdout_stderr():\nadriz(\ninput=self.working_source,\noutput=str(self.drz_target_dir / self.filtername),\n**self.drz_config\n)\n# get the resulting drizzled file(s)\nself.drizzled_files = self.drz_target_dir.glob(\"*drz*.fits\")\ndef apply_manual_shifts(self):\n\"\"\" Take a manual shift and apply it to either all images collectively or to each individual frame\n        \"\"\"\n# First parse to understand if we have a collective change or not\nif self.manual_shifts is None:\nif self.verbose:\nprint('No manual shifts specified')\npass\nif isinstance(self.manual_shift, dict):\nfor image in self.images:\nif image in self.manual_shifts.keys():\n# Add the shift to the working copy\nimage.shift_working_copy_wcs(self.manual_shifts[image]['dra'], self.manual_shifts[image]['ddec'])\n# also add it to the target\nimage.backpropagate_wcs(self.manual_shifts[image]['dra'], self.manual_shifts[image]['ddec'])\nelif isinstance(self.manual_shift, tuple):\nfor image in self.images:\nimage.shift_working_copy_wcs(self.manual_shifts[0], self.manual_shifts[1])\nimage.backpropagate_wcs(self.manual_shifts[0], self.manual_shifts[1])\ndef backpropagate_wcs_shift(self, dra, ddec):\n\"\"\" propagate the found wcs offset to all images\n        \"\"\"\nfor image in self.images:\nimage.backpropagate_wcs(dra, ddec)\ndef clean_temp_directories(self):\n\"\"\" Remove drizzling directories\"\"\"\nshutil.rmtree(self.drz_source_dir)\nshutil.rmtree(self.drz_target_dir)\ndef __repr__(self) -&gt; str:\nmsg = \"&lt; {} ImageSet instance containing: \".format(self.filtername)\nfor img in self.images:\nmsg += img + \", \"\nmsg += \"&gt;\"\nreturn msg\n</code></pre>"},{"location":"apidocs/#crocoa.filemanagement.ImageSet.__init__","title":"<code>__init__(file_list, filtername, drizzle_config, working_dir='./temp', destination_dir=None, manual_shifts=None, verbose=False, file_suffix=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>file_list</code> <code>list</code> <p>list of string file names to be included in the image set</p> required <code>filtername</code> <code>str</code> <p>Name of the current filter - just used to create subdirectories</p> required <code>drizzle_config</code> <code>dict</code> <p>configuration dictionary for astrodrizzle</p> required <code>working_dir</code> <code>str, optional</code> <p>sets the temp directory parent name</p> <code>'./temp'</code> <code>destination_dir</code> <code>str, optional</code> <p>This sets the directory where the resulting files with the backpropagated wcs' are put. If None this defaults  to './filtername_aligned'</p> <code>None</code> <code>manual_shifts</code> <code>dict or tuple</code> <p>Either a dictionary mapping dra ddec shifts to individual images in the set or a tuple with a global dra and ddec that should be applied to all the frames collectively</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>whether to output drizzle resutls</p> <code>False</code> <code>file_suffix</code> <code>str, optional</code> <p>suffix to append to the file name(s)</p> <code>None</code> Source code in <code>crocoa/filemanagement.py</code> <pre><code>def __init__(\nself, file_list, filtername, drizzle_config, working_dir=\"./temp\", destination_dir=None, manual_shifts=None, verbose=False, \nfile_suffix=None\n) -&gt; None:\n\"\"\"\n    Parameters\n    ----------\n    file_list : list\n        list of string file names to be included in the image set\n    filtername : str\n        Name of the current filter - just used to create subdirectories\n    drizzle_config : dict\n        configuration dictionary for astrodrizzle\n    working_dir : str, optional\n        sets the temp directory parent name\n    destination_dir : str, optional\n        This sets the directory where the resulting files with the backpropagated wcs' are put. If None this defaults \n        to './filtername_aligned'\n    manual_shifts : dict or tuple\n        Either a dictionary mapping dra ddec shifts to individual images in the set or a tuple with a global dra and\n        ddec that should be applied to all the frames collectively\n    verbose : bool\n        whether to output drizzle resutls\n    file_suffix : str, optional\n        suffix to append to the file name(s)\n    \"\"\"\nself.images = [Image(file_name, verbose=verbose, file_suffix=file_suffix) for file_name in file_list]\nself.verbose = verbose\nself.drz_config = drizzle_config\nself.filtername = filtername\nself.drz_source_dir = Path(working_dir) / \"drz_source\" / filtername\nself.drz_target_dir = Path(working_dir) / \"drz_target\" / filtername\nself.manual_shifts = manual_shifts\n# Set up destination files\nself.destination_dir = destination_dir\nif self.destination_dir is not None:\nself.destination_dir = Path(destination_dir)\nself.destination_dir.mkdir(parents=True)\nelse:\nself.destination_dir = Path('./{}_aligned'.format(filter))\nself.destination_dir.mkdir(parents=True)\n#set up drizzle files\nself.drz_source_dir.mkdir(parents=True)\nself.drz_target_dir.mkdir(parents=True)\n</code></pre>"},{"location":"apidocs/#crocoa.filemanagement.ImageSet.apply_manual_shifts","title":"<code>apply_manual_shifts()</code>","text":"<p>Take a manual shift and apply it to either all images collectively or to each individual frame</p> Source code in <code>crocoa/filemanagement.py</code> <pre><code>def apply_manual_shifts(self):\n\"\"\" Take a manual shift and apply it to either all images collectively or to each individual frame\n    \"\"\"\n# First parse to understand if we have a collective change or not\nif self.manual_shifts is None:\nif self.verbose:\nprint('No manual shifts specified')\npass\nif isinstance(self.manual_shift, dict):\nfor image in self.images:\nif image in self.manual_shifts.keys():\n# Add the shift to the working copy\nimage.shift_working_copy_wcs(self.manual_shifts[image]['dra'], self.manual_shifts[image]['ddec'])\n# also add it to the target\nimage.backpropagate_wcs(self.manual_shifts[image]['dra'], self.manual_shifts[image]['ddec'])\nelif isinstance(self.manual_shift, tuple):\nfor image in self.images:\nimage.shift_working_copy_wcs(self.manual_shifts[0], self.manual_shifts[1])\nimage.backpropagate_wcs(self.manual_shifts[0], self.manual_shifts[1])\n</code></pre>"},{"location":"apidocs/#crocoa.filemanagement.ImageSet.backpropagate_wcs_shift","title":"<code>backpropagate_wcs_shift(dra, ddec)</code>","text":"<p>propagate the found wcs offset to all images</p> Source code in <code>crocoa/filemanagement.py</code> <pre><code>def backpropagate_wcs_shift(self, dra, ddec):\n\"\"\" propagate the found wcs offset to all images\n    \"\"\"\nfor image in self.images:\nimage.backpropagate_wcs(dra, ddec)\n</code></pre>"},{"location":"apidocs/#crocoa.filemanagement.ImageSet.clean_temp_directories","title":"<code>clean_temp_directories()</code>","text":"<p>Remove drizzling directories</p> Source code in <code>crocoa/filemanagement.py</code> <pre><code>def clean_temp_directories(self):\n\"\"\" Remove drizzling directories\"\"\"\nshutil.rmtree(self.drz_source_dir)\nshutil.rmtree(self.drz_target_dir)\n</code></pre>"},{"location":"apidocs/#crocoa.filemanagement.ImageSet.drizzle","title":"<code>drizzle(individual=False)</code>","text":"<p>Run the drizzling process</p> Source code in <code>crocoa/filemanagement.py</code> <pre><code>def drizzle(self, individual=False):\n\"\"\" Run the drizzling process\"\"\"\nself.drizzled_files = []\nif individual:\nfor image in self.working_source:\nif self.verbose:\nadriz(\ninput=[image],\noutput=str(\nself.drz_target_dir / os.path.basename(image).split(\".\")[0]\n),\n**self.drz_config\n)\nelse:\nwith suppress_stdout_stderr():\nadriz(\ninput=[image],\noutput=str(\nself.drz_target_dir / os.path.basename(image).split(\".\")[0]\n),\n**self.drz_config\n)\nself.drizzled_files.append(\nself.drz_target_dir.glob(\nos.path.basename(image).split(\".\")[0] + \"*drz*.fits\"\n)\n)\nelse:\nif self.verbose:\nadriz(\ninput=self.working_source,\noutput=str(self.drz_target_dir / self.filtername),\n**self.drz_config\n)\nelse:\nwith suppress_stdout_stderr():\nadriz(\ninput=self.working_source,\noutput=str(self.drz_target_dir / self.filtername),\n**self.drz_config\n)\n# get the resulting drizzled file(s)\nself.drizzled_files = self.drz_target_dir.glob(\"*drz*.fits\")\n</code></pre>"},{"location":"apidocs/#crocoa.filemanagement.ImageSet.make_all_copies","title":"<code>make_all_copies()</code>","text":"<p>Create all relevant file copies</p> Source code in <code>crocoa/filemanagement.py</code> <pre><code>def make_all_copies(self):\n\"\"\" Create all relevant file copies\"\"\"\nself.make_target_copies()\nself.make_driz_source()\n</code></pre>"},{"location":"apidocs/#crocoa.filemanagement.ImageSet.make_driz_source","title":"<code>make_driz_source()</code>","text":"<p>Make source file copies since drizzle changes the source files it's run on</p> Source code in <code>crocoa/filemanagement.py</code> <pre><code>def make_driz_source(self):\n\"\"\" Make source file copies since drizzle changes the source files it's run on\"\"\"\nself.working_source = []\nfor image in self.images:\nimage.make_working_copy(self.drz_source_dir)\nself.working_source.append(image.working_copy)\n</code></pre>"},{"location":"apidocs/#crocoa.filemanagement.ImageSet.make_target_copies","title":"<code>make_target_copies()</code>","text":"<p>Make target file copies</p> Source code in <code>crocoa/filemanagement.py</code> <pre><code>def make_target_copies(self):\n\"\"\" Make target file copies\"\"\"\nfor img in self.images:\nimg.make_target_copy(self.destination_dir)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Here are some examples of primary use cases for the code</p> <p>The examples here assumes that the flt frames have been pipeline processed and </p>"},{"location":"examples/#aligning-frames-within-a-single-filter","title":"Aligning frames within a single filter","text":"<p>Add the central Ra and Dec to the drizzle configuration </p> <pre><code>from crocoa.drizzle_config import config\nconfig['final_ra'] = 1.12637\nconfig['final_dec'] = -10.19156\n</code></pre> <p>Set up the working directory and create an <code>ImageSet</code></p> <p>Warning</p> <p>This will change the world coordinate systems of the flt files that are given to the ImageSet.  Making copies is always advisable</p> <pre><code>from crocoa.filemanagement import ImageSet\nfrom pathlib import Path\nsource_dir = Path('path/to/flts')\nflt_frames = list(source_dir.glob('*.flt'))\nimg_set = ImageSet(flt_frames, filtername=\"F150LP\", drizzle_config=config)\n</code></pre> <p>Use the align filter function to align the images in the <code>ImageSet</code> <pre><code>from crocoa.imalign import align_single_filter\nalign_single_filter(img_set)\n</code></pre></p>"},{"location":"examples/#aligning-frames-between-several-filters","title":"Aligning frames between several filters","text":"<p>This is done in a very similar manner to aligning a single filter, however the difference is that  we pass several ImageSets as a list rather than a single image set</p> <p>Note</p> <p>This assumes that each individual filter has already been aligned internally according to the process outlined above.</p> <pre><code>from crocoa.filemanagement import ImageSet\nfrom crocoa.imalign import align_multiple_filters\nfrom crocoa.drizzle_config import config\nfrom pathlib import Path\nconfig['final_ra'] = 1.12637\nconfig['final_dec'] = -10.19156\n# Filter 1\nsource_dir = Path('path/to/filter1/flts')\nflt_frames = list(source_dir.glob('*.flt'))\nimg_set1 = ImageSet(flt_frames, filtername=\"filter1\", drizzle_config=config)\n# Filter 2\nsource_dir = Path('path/to/filter2/flts')\nflt_frames = list(source_dir.glob('*.flt'))\nimg_set2 = ImageSet(flt_frames, filtername=\"filter2\", drizzle_config=config)\nimg_sets = [img_set1, img_set2]\nalign_multiple_filters(img_sets)\n</code></pre>"},{"location":"examples/#tweaking-configuration","title":"Tweaking configuration","text":"<p>If you want to pass more detailed configurations to the internal steps this is done in 2 ways</p>"},{"location":"examples/#changing-drizzle-configuration-settings","title":"Changing Drizzle configuration settings","text":"<p>The default drizzle configuration settings used in the code are located in <code>crocoa.drizzle_config</code> and are passed as a dictionary</p> <p>If you wish to examine or alter these you can simply import these settings, alter them and pass the new dictionary to the ImageSet constructor when you set it up</p> <pre><code>from crocoa.filemanagement import ImageSet\nfrom crocoa.drizzle_config import config\n# Examine the values in the current config\nfor k in config.keys():\nprint(k, ': ', config[k])\n# Change one \nconfig[final_scale] = 0.02\n# Then pass it to your image set \n</code></pre>"},{"location":"examples/#changing-image-correlation-settings","title":"Changing image correlation settings","text":"<p>The settings available for the image correlation are the keywords specified for the <code>match_images</code> function</p> <ul> <li><code>verbose=True</code></li> <li><code>normalization=\"white\"</code></li> <li><code>clip=None</code></li> <li><code>mask_method=\"zero\"</code></li> </ul> <p>The verbosity sets the detail of the printout for each matching. When not debugging it can be useful to set this to false to prevent  an enormous amount of terminal output from astro_drizzle</p> <p>The normalization sets what method is used to normalize the images before running the cross correlation. </p> <p>The clip argument sets whether some range of values should be clipped out of the image. </p> <p>The mask method sets what way nan values in the resulting drizzled images should be handled. By default they are just set to zero</p> <p>To change these arguments one passes a dictionary to the align function </p> <pre><code>from crocoa.imalign import align_single_filter\n# Lets use a minmax normalization in the matching \ncrosscorr_config = {'normalization': 'minmax'}\nalign_single_filter(img_set, matching_config=crosscorr_config)\n</code></pre>"},{"location":"manual_shifts/","title":"Adding manual shifts to the images","text":"<p>In many cases the wcs of a filter or even an individual frame may be significantly offset from the others in a set. In this case one may be forced to use a relatively large region in the drizzling configuration. To avoid this the code allows for adding shifts to the RA and dec manually both to entire filters and to individual frames.</p>"},{"location":"manual_shifts/#shifting-individual-frames","title":"Shifting individual frames","text":"<p>It is not uncommon that a given exposure may be significantly shifted from the others in a set  especially if exposures were taken in different visits. In this case the <code>manual_shifts</code> parameter needs to be a dictionary specifying the full filename (not full path) of the frame that needs shifting. for each such frame the shift is then given by a nested dict with the <code>'dra'</code> and <code>'ddec'</code> keys. </p> <p>The offsets are given in decimal degrees</p> <p><pre><code>manual_shifts = {\n'full_filename_flt.fits':{\n'dra': 0.02,\n'ddec': 0.01,\n}, \n'full_filename2_flt.fits':{\n'dra': -0.02,\n'ddec': 0.01,\n}\n}\n</code></pre> One does not have to specify shifts for all of the frames in a given image set. This is then given to the  <code>ImageSet</code>during construction</p>"},{"location":"manual_shifts/#adding-a-shift-to-all-frames-in-a-filter","title":"Adding a shift to all frames in a filter","text":"<p>This is only relevant after the frames in the filter have been aligned internally but instead of giving the shifts for individual frame names, they are simply specified as tuple of <code>(dra, ddec)</code> given to the relevant ImageSet</p> <pre><code>from crocoa.filemanagement import ImageSet\nfrom crocoa.imalign import align_multiple_filters\nfrom crocoa.drizzle_config import config\nfrom pathlib import Path\nconfig['final_ra'] = 1.12637\nconfig['final_dec'] = -10.19156\nmanual_shifts = (0.002, 0.2)\n# Filter 1\nsource_dir = Path('path/to/filter1/flts')\nflt_frames = list(source_dir.glob('*.flt'))\nimg_set1 = ImageSet(flt_frames, drizzle_config=config, manual_shifts=manual_shifts)\n... \n# Remaining filters etc\n</code></pre>"},{"location":"potential_problems/","title":"Potential Problems and suggested solutions","text":"<p>Most problems will appear as insufficient, poor or simply incorrect corrections and unfortunately this can have many reasons, each of which has it's own set of solutions.</p>"},{"location":"potential_problems/#window-size","title":"Window size","text":"<p>The 2D correlation is very sensitive to noise. This means that we want the iage size used for correlation to be as small as possible  while still containing the main galaxy structure. </p> <p>In the case of large offsets one may need to apply manual offsets in order to bring the images einto approximate alignment before  running the code. This is described here.</p>"},{"location":"potential_problems/#normalization","title":"Normalization","text":"<p>Before the crosscorrelation is done the images need to be normalized. This can be done in several different ways and certain datasets are more or less  suitable for a given method, depending on the pixel-statistics of a given individual image.</p>"},{"location":"potential_problems/#cr-rejection","title":"CR Rejection","text":"<p>If there are cosmic rays present in an image this will naturally make the cross correlation difficult. This is not an issue for ACS/SBC since the mama detector does not show cosmic rays. </p> <p>CRs need to be masked separately before crosscorrelation and making sure that they are masked properly is crucial. We recommend using <code>astroscrappy</code>.</p> <p>However, when the drizzling is done in CROCOA it is done with a very small pixel scale which can lead to issues where some final pixels only have  contributions from masked pixels. </p>"}]}