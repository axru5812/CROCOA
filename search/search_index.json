{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CROCOA","text":"<p>CRoss COrrelation Alignment tool. </p> <p>Software package for using 2D crosscorrelation to align astronomical images.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>The primary requirements are astropy and scipy in order to manage the fits files and 2d correlation function. Additionally drizzlepac is also used to drizzle the frames in order to account for differing pixel grids and rotation</p> <p>The package is tested on python 3.7</p>"},{"location":"#installation","title":"Installation","text":"<p>For having an editable installation activate your preferred virtualenv and run the following in the CROCOA main directory</p> <pre><code>$ python setup.py develop\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#example","title":"Example:","text":"<pre><code>import os\nimport glob\nfrom crocoa.imalign import align\nfrom crocoa.drizzle_config import config\n\n# Review the drizzle config settings\nfor k in config.keywords():\n    print(k, ': ', config[k])\n\n# Set the Ra and dec in the drizzle config to accurate values\nconfig['final_ra'] = 1.12637\nconfig['final_dec'] = -10.19156\n\n# Prepare your directories\nsource_images = glob.glob(\"SDSSJ0004-1011/F150LP/*\")\n\ndestination_dir = \"SDSSJ0004-1011/F150LP_aligned/\"\nos.mkdir(destination_dir)\n\n# Run alignment\nalign(source_images, destination_dir, config)\n</code></pre>"},{"location":"#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"#image-size","title":"Image size","text":"<p>The 2D correlation is very sensitive to the relative size of the target to the frame i.e. a small target in a large frame can give poor results. Therefore it can be useful to minimize the size of the frame considered while still makeing sure that the full target is contained.</p> <p>In cases where the alignment is very poor this can require manual correction of the coordinate system beforehand.</p>"},{"location":"#image-normalization","title":"Image normalization","text":"<p>How the image is normalized before being run through the 2D correlation can also impact the quality of the alignment. test setting the normalization keyword to different settings.</p>"},{"location":"#always-check-manually","title":"Always check manually","text":"<p>What the title says. The system is most definitely not infallible.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>Contributions are welcome in the form of pull requests and issue submissions.</p>"},{"location":"apidocs/","title":"API Documentation","text":""},{"location":"apidocs/#crocoa.imalign.align","title":"<code>align(source_images, destination_dir, run_drizzle=True, drizzle_config=None, drizzle_groups=None, temp_dir='./temp', reference_image=None, cleanup=True, normalization='white', hlet=False, manual_shift=None, mask_method='zeros', verbose=False)</code>","text":"<p>Function for aligning two image sets</p> <p>Parameters:</p> Name Type Description Default <code>source_images</code> <code>list of str</code> <p>List or array containing the images that are to be aligned</p> required <code>destination_dir</code> <code>str</code> <p>directory in which to put matched files</p> required <code>run_drizzle</code> <code>bool</code> <p>whether or not to drizzle the frames before comparing. If false the source images are assumed to be drizzled</p> <code>True</code> <code>drizzle_config</code> <code>dict</code> <p>dictionary with astrodrizzle configuration settings</p> <code>None</code> <code>drizzle_groups</code> <code>list of lists</code> <p>list containing the groupings of which frames that should be drizzled together. If <code>None</code>each frame is drizzled separately.</p> <code>None</code> <code>temp_dir</code> <code>str</code> <p>Directory where intermediate results are stored</p> <code>'./temp'</code> <code>reference_image</code> <code>str or None</code> <p>sets the reference image for the correlation (full path of the image)</p> <code>None</code> <code>cleanup</code> <code>bool, default</code> <p>whether or not to remove the temp_dir</p> <code>True</code> <code>normalization</code> <code>str</code> <p>Parameter passed to the image_normalization function.</p> <code>'white'</code> <code>mask_method</code> <code>str</code> <p>NaN treatment in drizzled frames, 'zero' (default) or 'skimage'.</p> <code>'zeros'</code> <code>hlet</code> <code>bool</code> <p>whether to store the new coord system as an hlet in the fits. Not implemented</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>whether to show the output of astrodrizzle</p> <code>False</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def align(\n    source_images,\n    destination_dir,\n    run_drizzle=True,\n    drizzle_config=None,\n    drizzle_groups=None,\n    temp_dir=\"./temp\",\n    reference_image=None,\n    cleanup=True,\n    normalization=\"white\",\n    hlet=False,\n    manual_shift=None,\n    mask_method=\"zeros\",\n    verbose=False,\n):\n\"\"\"Function for aligning two image sets\n    Parameters\n    ----------\n    source_images : list of str\n        List or array containing the images that are to be aligned\n    destination_dir : str\n        directory in which to put matched files\n    run_drizzle : bool\n        whether or not to drizzle the frames before comparing. If false the source images are assumed to be drizzled\n    drizzle_config : dict\n        dictionary with astrodrizzle configuration settings\n    drizzle_groups : list of lists\n        list containing the groupings of which frames that should be drizzled together.\n        If `None`each frame is drizzled separately.\n    temp_dir : str\n        Directory where intermediate results are stored\n    reference_image : str or None\n        sets the reference image for the correlation (full path of the image)\n    cleanup : bool, default = True\n        whether or not to remove the temp_dir\n    normalization : str\n        Parameter passed to the image_normalization function.\n    mask_method : str\n        NaN treatment in drizzled frames, 'zero' (default) or 'skimage'.\n    hlet : bool\n        whether to store the new coord system as an hlet in the fits. Not implemented\n    verbose : bool\n        whether to show the output of astrodrizzle\n\n    \"\"\"\n    # Step 1: make drizzle copies\n    # Create working dir\n    if not os.path.isdir(temp_dir):\n        os.mkdir(temp_dir)\n    else:\n        # here we want to deal with an already existing temp directory which\n        # can screw us over\n        temp_dir = temp_dir + datetime.now().strftime(\"%m%d%Y_%H%M%S\")\n        os.mkdir(temp_dir)\n        if verbose:\n            print('Warning: Previous temp-directory found. Renaming temp to: ' + temp_dir)\n\n\n\n    driz_source_dir = temp_dir + \"/raw_images/\"\n    driz_destination_dir = temp_dir + \"/drizzled_images/\"\n    if not os.path.isdir(driz_destination_dir):\n        os.mkdir(driz_destination_dir)\n    driz_source_files = fm.make_copy(source_images, driz_source_dir, verbose=verbose)\n\n    if manual_shift is not None:\n        assert type(manual_shift) is dict\n        manual_wcs_shift(driz_source_files, manual_shift)\n\n    # Step 2: drizzle\n    if run_drizzle:\n        # TODO: generalize this to be able to take groups of files as well\n        for fd_frame in driz_source_files:\n            if verbose:\n                adriz(\n                    input=[fd_frame],\n                    output=driz_destination_dir\n                    + os.path.basename(fd_frame).split(\".\")[0],\n                    **drizzle_config\n                )\n            else:\n                with suppress_stdout_stderr():\n                    adriz(\n                        input=[fd_frame],\n                        output=driz_destination_dir\n                        + os.path.basename(fd_frame).split(\".\")[0],\n                        **drizzle_config\n                    )\n\n        # Step 4: Copy files to destination dir\n        if not os.path.isdir(destination_dir):\n            os.mkdir(destination_dir)\n\n    destination_files = fm.make_copy(\n        source_images, destination_dir + \"/\", verbose=verbose\n    )\n\n    # Step 3: Cross Correlate\n    if run_drizzle:\n        corr_source_files = glob.glob(driz_destination_dir + \"*sci*\")\n    else:\n        corr_source_files = source_images\n    if reference_image is None:\n        reference_image = corr_source_files[0]\n        corr_source_files = corr_source_files[1:]\n    else:\n        if run_drizzle:\n            ref = glob.glob(driz_destination_dir + os.path.basename(reference_image))\n            if ref:\n                reference_image = ref[0]\n            else:\n                print(\"Cannot find reference image. Falling back to using first image\")\n                reference_image = corr_source_files[0]\n                corr_source_files = corr_source_files[1:]\n        else:\n            ref = reference_image\n\n    for frame in corr_source_files:\n        destination_file = glob.glob(\n            destination_dir + \"/\" + os.path.basename(frame).split(\"_\")[0] + \"*\"\n        )\n        match_images(\n            reference_image,\n            frame,\n            destination_file,\n            normalization=normalization,\n            mask_method=mask_method,\n        )\n        if manual_shift is not None:\n            print()\n            print(\"manual shift\")\n            manual_wcs_shift(destination_file, manual_shift)\n            print()\n\n    # Add the manual shift to the reference file\n    if manual_shift is not None:\n        reference_destination = destination_file = glob.glob(\n            destination_dir\n            + \"/\"\n            + os.path.basename(reference_image).split(\"_\")[0]\n            + \"*\"\n        )\n        manual_wcs_shift(reference_destination, manual_shift)\n\n    # Step 5: Cleanup\n    if cleanup:\n        fm.cleanup(temp_dir)\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.align_multiple_filters","title":"<code>align_multiple_filters(image_sets, reference_set_index=0)</code>","text":"<p>Function for aligning image sets between multiple filters</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def align_multiple_filters(image_sets, reference_set_index=0):\n\"\"\" Function for aligning image sets between multiple filters \n    \"\"\"\n    source_images = []\n    for image_set in image_sets:\n        image_set.drizzle()\n        source_images.append(image_set.drizzled_files)\n\n    reference_image = source_images[reference_set_index]\n    for i, image in source_images:\n        if i == reference_set_index:\n            pass\n        else:\n            dra, ddec = match_images(reference_image, image)\n            image_sets[i].backpropagate_wcs_shift(dra, ddec)\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.corr2d","title":"<code>corr2d(image_to_shift, refimage)</code>","text":"<p>Function for calculating the x and y shift required for image <code>image_to_shift</code> to be matched to <code>refimage</code></p> <p>Parameters:</p> Name Type Description Default <code>image_to_shift</code> <code>np.ndarray</code> <p>image_array</p> required <code>refimage</code> <code>np.ndarray</code> <p>image_array</p> required <p>Returns:</p> Name Type Description <code>x_shift</code> <code>int</code> <code>y_shift</code> <code>int</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def corr2d(image_to_shift, refimage):\n\"\"\"Function for calculating the x and y shift required for image\n    `image_to_shift` to be matched to `refimage`\n\n    Parameters\n    ----------\n    image_to_shift : np.ndarray\n        image_array\n    refimage : np.ndarray\n        image_array\n\n    Returns\n    -------\n    x_shift : int\n    y_shift : int\n    \"\"\"\n    corr = correlate2d(image_to_shift, refimage, mode=\"same\")\n    shift = np.where(corr == corr.max())\n    shift = (\n        -1 * (shift[0] % refimage.shape[0] - refimage.shape[0] / 2 + 1),\n        -1 * (shift[1] % refimage.shape[1] - refimage.shape[0] / 2 + 1),\n    )\n\n    return shift[1][0], shift[0][0]\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.corr2d_sk","title":"<code>corr2d_sk(refima, ima, mask_ref, mask_ima)</code>","text":"<p>Performs (masked) cross correlation with scikit_image</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def corr2d_sk(refima, ima, mask_ref, mask_ima):\n\"\"\"Performs (masked) cross correlation with scikit_image\"\"\"\n    shift = phase_cross_correlation(\n        refima, ima, reference_mask=mask_ref, moving_mask=mask_ima\n    )\n    # shifts are given as {row, col}\n    return shift[1], shift[0]\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.dpixels_to_dwcs","title":"<code>dpixels_to_dwcs(dx, dy, pixscale_x, pixscale_y, ref_dec)</code>","text":"<p>Converts from pixel shifts to shifts in ra and declination</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def dpixels_to_dwcs(dx, dy, pixscale_x, pixscale_y, ref_dec):\n\"\"\"Converts from pixel shifts to shifts in ra and declination\"\"\"\n    d_dec = dy * pixscale_y\n\n    d_ra = dx * pixscale_x * np.cos(np.deg2rad(ref_dec))\n    return d_ra, d_dec\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.get_image_coords","title":"<code>get_image_coords(header)</code>","text":"<p>Fetches RA and dec from a given header</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def get_image_coords(header):\n\"\"\"Fetches RA and dec from a given header\"\"\"\n    return header[\"CRVAL1\"], header[\"CRVAL2\"]\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.image_normalization","title":"<code>image_normalization(image, method='range', lower=0, higher=50, mask=None)</code>","text":"<p>Normalizes an np.array</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>input image array</p> required <code>method</code> <p>sets type of normalization. Default \"white\"</p> <p>minmax - subtract minimum value and divide by maximum</p> <p>white - subtract mean divide by standard deviation</p> <p>range - clips image data to range 0 to 100</p> <code>\"white\"</code> <code>mask</code> <code>ndarray(boolean)</code> <p>mask array for input image, valid pixels are True.</p> <p>Default: All pixels valid. NB masked pixels are set to 0 for statistics.</p> <code>None</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def image_normalization(image, method=\"range\", lower=0, higher=50, mask=None):\n\"\"\"Normalizes an np.array\n\n    Parameters\n    ----------\n    image : ndarray\n        input image array\n    method : {\"white\", \"minmax\", \"range\"}\n        sets type of normalization. Default \"white\"\n\n        minmax - subtract minimum value and divide by maximum\n\n        white - subtract mean divide by standard deviation\n\n        range - clips image data to range 0 to 100\n    mask : ndarray (boolean)\n        mask array for input image, valid pixels are True.\n\n        Default: All pixels valid. NB masked pixels are set to 0 for statistics.\n    \"\"\"\n\n    if mask is None:\n        mask = np.ones(image.shape, dtype=\"bool\")\n\n    image = np.where(mask, image, 0.0)\n    if method is None:\n        img = image\n    elif method == \"white\":\n        img = (image - image.mean()) / image.std()\n    elif method == \"minmax\":\n        img = (image - image.min()) / image.max()\n    elif method == \"range\":\n        img = np.clip(image, lower, higher)\n    elif method == \"clip_pixels\":\n        sorted_pixels = np.sort(image.flatten())\n        lower_range = sorted_pixels[lower]\n\n        higher_range = sorted_pixels[-higher]\n\n        img = np.clip(image, lower_range, higher_range)\n    elif method == \"percentile\":\n        img = np.clip(image, np.percentile(image, lower), np.percentile(image, higher))\n    else:\n        raise ValueError\n\n    return img\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.manual_wcs_shift","title":"<code>manual_wcs_shift(image_list, shift_dict)</code>","text":"<p>Function for applying a manual alteration of the WCS Primarily for doing rough alignment before correlation analysis</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def manual_wcs_shift(image_list, shift_dict):\n\"\"\"Function for applying a manual alteration of the WCS\n    Primarily for doing rough alignment before correlation analysis\n    \"\"\"\n    for img in image_list:\n        visit_name = os.path.basename(img).split(\"_\")[0]\n        if visit_name in shift_dict.keys():\n            fm.write_wcs_to_fits(\n                img, shift_dict[visit_name][\"dra\"], shift_dict[visit_name][\"ddec\"]\n            )\n            print(\"Applied manual correction to: \", img)\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.match_images","title":"<code>match_images(reference_fits, image_fits, verbose=True, normalization='white', clip=None, mask_method='zero')</code>","text":"<p>Function that matches the coordinatesystem of image_fits to that of reference_fits by means of cross-correlation</p> <p>Parameters:</p> Name Type Description Default <code>reference_fits</code> <code>str</code> <p>directory of the reference image</p> required <code>image_fits</code> <code>str</code> <p>directory of the image that should be matched</p> required <code>output_fits</code> <code>list</code> <p>path to original flc files where wcs should be updated</p> required Source code in <code>crocoa/imalign.py</code> <pre><code>def match_images(\n    reference_fits,\n    image_fits,\n    verbose=True,\n    normalization=\"white\",\n    clip=None,\n    mask_method=\"zero\",\n):\n\"\"\"Function that matches the coordinatesystem of image_fits\n    to that of reference_fits by means of cross-correlation\n\n    Parameters\n    ----------\n    reference_fits : str\n        directory of the reference image\n    image_fits : str\n        directory of the image that should be matched\n    output_fits : list\n        path to original flc files where wcs should be updated\n    \"\"\"\n    if verbose:\n        print(\"ref\", reference_fits)\n        print(\"shift image\", image_fits)\n\n    # 1. Read data\n    refdata = fits.getdata(reference_fits)\n    refheader = fits.getheader(reference_fits)\n\n    shiftdata = fits.getdata(image_fits)\n    shiftheader = fits.getheader(image_fits)\n\n    # 1.01 Check if there are nans in data and create masks in that case\n    # masks are True on valid pixels\n    if np.any(np.isnan(refdata)):\n        refmask = ~np.isnan(refdata)\n    else:\n        refmask = np.ones(refdata.shape, dtype=\"bool\")\n    if np.any(np.isnan(shiftdata)):\n        shiftmask = ~np.isnan(shiftdata)\n    else:\n        shiftmask = np.ones(shiftdata.shape, dtype=\"bool\")\n\n    # 1.1 Normalize data\n    if clip is not None:\n        shiftdata = image_normalization(\n            shiftdata,\n            method=\"range\",\n            lower=0,\n            higher=None,\n            mask=shiftmask,\n        )\n        refdata = image_normalization(\n            refdata,\n            method=\"range\",\n            lower=0,\n            higher=None,\n            mask=refmask,\n        )\n    shiftdata_n = image_normalization(shiftdata, method=normalization, mask=shiftmask)\n    refdata_n = image_normalization(refdata, method=normalization, mask=refmask)\n\n    # 2. Get cross correlation shifts\n    if (np.any(np.isnan(refdata)) | np.any(np.isnan(shiftdata))) &amp; (\n        mask_method == \"skimage\"\n    ):\n        # run scikit correlate to deal with masked pixels\n        print(\"Warning: NaN pixels in input data (skimage masked correlation chosen).\")\n        xshift, yshift = corr2d_sk(refdata_n, shiftdata_n, refmask, shiftmask)\n    else:\n        shiftdata_n = np.where(shiftmask, shiftdata_n, 0.0)\n        refdata_n = np.where(refmask, refdata_n, 0.0)\n        xshift, yshift = corr2d(shiftdata_n, refdata_n)\n\n    if verbose:\n        print(\"X shift: \", xshift)\n        print(\"Y shift: \", yshift)\n\n    # 3. Translate into Ra and dec\n    xscale, yscale = get_pixel_scale(shiftheader)\n    ra, dec = get_image_coords(shiftheader)\n    dra, ddec = dpixels_to_dwcs(xshift, yshift, xscale, yscale, dec)\n    if verbose:\n        print(\"Delta RA: \", dra)\n        print(\"Delta DEC: \", ddec)\n\n    return dra, ddec\n</code></pre>"}]}