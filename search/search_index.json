{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CROCOA","text":"<p>CRoss COrrelation Alignment tool. </p> <p>Software package for using 2D crosscorrelation to align astronomical images.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>The primary requirements are astropy and scipy in order to manage the fits files and 2d correlation function. Additionally drizzlepac is also used to drizzle the frames in order to account for differing pixel grids and rotation</p> <p>The package is tested on python 3.7</p>"},{"location":"#installation","title":"Installation","text":"<p>For having an editable installation activate your preferred virtualenv and run the following in the CROCOA main directory</p> <pre><code>$ python setup.py develop\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#example","title":"Example:","text":"<pre><code>import os\nimport glob\nfrom crocoa.imalign import align\nfrom crocoa.drizzle_config import config\n# Review the drizzle config settings\nfor k in config.keywords():\nprint(k, ': ', config[k])\n# Set the Ra and dec in the drizzle config to accurate values\nconfig['final_ra'] = 1.12637\nconfig['final_dec'] = -10.19156\n# Prepare your directories\nsource_images = glob.glob(\"SDSSJ0004-1011/F150LP/*\")\ndestination_dir = \"SDSSJ0004-1011/F150LP_aligned/\"\nos.mkdir(destination_dir)\n# Run alignment\nalign(source_images, destination_dir, config)\n</code></pre>"},{"location":"#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"#image-size","title":"Image size","text":"<p>The 2D correlation is very sensitive to the relative size of the target to the frame i.e. a small target in a large frame can give poor results. Therefore it can be useful to minimize the size of the frame considered while still makeing sure that the full target is contained.</p> <p>In cases where the alignment is very poor this can require manual correction of the coordinate system beforehand.</p>"},{"location":"#image-normalization","title":"Image normalization","text":"<p>How the image is normalized before being run through the 2D correlation can also impact the quality of the alignment. test setting the normalization keyword to different settings.</p>"},{"location":"#always-check-manually","title":"Always check manually","text":"<p>What the title says. The system is most definitely not infallible.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>Contributions are welcome in the form of pull requests and issue submissions.</p>"},{"location":"apidocs/","title":"API Documentation","text":""},{"location":"apidocs/#crocoa.imalign.align","title":"<code>align(source_images, destination_dir, run_drizzle=True, drizzle_config=None, drizzle_groups=None, temp_dir='./temp', reference_image=None, cleanup=True, normalization='white', hlet=False, manual_shift=None, mask_method='zeros', verbose=False)</code>","text":"<p>Function for aligning two image sets</p> <p>Parameters:</p> Name Type Description Default <code>source_images</code> <code>list of str</code> <p>List or array containing the images that are to be aligned</p> required <code>destination_dir</code> <code>str</code> <p>directory in which to put matched files</p> required <code>run_drizzle</code> <code>bool</code> <p>whether or not to drizzle the frames before comparing. If false the source images are assumed to be drizzled</p> <code>True</code> <code>drizzle_config</code> <code>dict</code> <p>dictionary with astrodrizzle configuration settings</p> <code>None</code> <code>drizzle_groups</code> <code>list of lists</code> <p>list containing the groupings of which frames that should be drizzled together. If <code>None</code>each frame is drizzled separately.</p> <code>None</code> <code>temp_dir</code> <code>str</code> <p>Directory where intermediate results are stored</p> <code>'./temp'</code> <code>reference_image</code> <code>str or None</code> <p>sets the reference image for the correlation (full path of the image)</p> <code>None</code> <code>cleanup</code> <code>bool, default</code> <p>whether or not to remove the temp_dir</p> <code>True</code> <code>normalization</code> <code>str</code> <p>Parameter passed to the image_normalization function.</p> <code>'white'</code> <code>mask_method</code> <code>str</code> <p>NaN treatment in drizzled frames, 'zero' (default) or 'skimage'.</p> <code>'zeros'</code> <code>hlet</code> <code>bool</code> <p>whether to store the new coord system as an hlet in the fits. Not implemented</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>whether to show the output of astrodrizzle</p> <code>False</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def align(\nsource_images,\ndestination_dir,\nrun_drizzle=True,\ndrizzle_config=None,\ndrizzle_groups=None,\ntemp_dir=\"./temp\",\nreference_image=None,\ncleanup=True,\nnormalization=\"white\",\nhlet=False,\nmanual_shift=None,\nmask_method=\"zeros\",\nverbose=False,\n):\n\"\"\"Function for aligning two image sets\n    Parameters\n    ----------\n    source_images : list of str\n        List or array containing the images that are to be aligned\n    destination_dir : str\n        directory in which to put matched files\n    run_drizzle : bool\n        whether or not to drizzle the frames before comparing. If false the source images are assumed to be drizzled\n    drizzle_config : dict\n        dictionary with astrodrizzle configuration settings\n    drizzle_groups : list of lists\n        list containing the groupings of which frames that should be drizzled together.\n        If `None`each frame is drizzled separately.\n    temp_dir : str\n        Directory where intermediate results are stored\n    reference_image : str or None\n        sets the reference image for the correlation (full path of the image)\n    cleanup : bool, default = True\n        whether or not to remove the temp_dir\n    normalization : str\n        Parameter passed to the image_normalization function.\n    mask_method : str\n        NaN treatment in drizzled frames, 'zero' (default) or 'skimage'.\n    hlet : bool\n        whether to store the new coord system as an hlet in the fits. Not implemented\n    verbose : bool\n        whether to show the output of astrodrizzle\n    \"\"\"\n# Step 1: make drizzle copies\n# Create working dir\nif not os.path.isdir(temp_dir):\nos.mkdir(temp_dir)\nelse:\n# here we want to deal with an already existing temp directory which\n# can screw us over\ntemp_dir = temp_dir + datetime.now().strftime(\"%m%d%Y_%H%M%S\")\nos.mkdir(temp_dir)\nif verbose:\nprint('Warning: Previous temp-directory found. Renaming temp to: ' + temp_dir)\ndriz_source_dir = temp_dir + \"/raw_images/\"\ndriz_destination_dir = temp_dir + \"/drizzled_images/\"\nif not os.path.isdir(driz_destination_dir):\nos.mkdir(driz_destination_dir)\ndriz_source_files = fm.make_copy(source_images, driz_source_dir, verbose=verbose)\nif manual_shift is not None:\nassert type(manual_shift) is dict\nmanual_wcs_shift(driz_source_files, manual_shift)\n# Step 2: drizzle\nif run_drizzle:\n# TODO: generalize this to be able to take groups of files as well\nfor fd_frame in driz_source_files:\nif verbose:\nadriz(\ninput=[fd_frame],\noutput=driz_destination_dir\n+ os.path.basename(fd_frame).split(\".\")[0],\n**drizzle_config\n)\nelse:\nwith suppress_stdout_stderr():\nadriz(\ninput=[fd_frame],\noutput=driz_destination_dir\n+ os.path.basename(fd_frame).split(\".\")[0],\n**drizzle_config\n)\n# Step 4: Copy files to destination dir\nif not os.path.isdir(destination_dir):\nos.mkdir(destination_dir)\ndestination_files = fm.make_copy(\nsource_images, destination_dir + \"/\", verbose=verbose\n)\n# Step 3: Cross Correlate\nif run_drizzle:\ncorr_source_files = glob.glob(driz_destination_dir + \"*sci*\")\nelse:\ncorr_source_files = source_images\nif reference_image is None:\nreference_image = corr_source_files[0]\ncorr_source_files = corr_source_files[1:]\nelse:\nif run_drizzle:\nref = glob.glob(driz_destination_dir + os.path.basename(reference_image))\nif ref:\nreference_image = ref[0]\nelse:\nprint(\"Cannot find reference image. Falling back to using first image\")\nreference_image = corr_source_files[0]\ncorr_source_files = corr_source_files[1:]\nelse:\nref = reference_image\nfor frame in corr_source_files:\ndestination_file = glob.glob(\ndestination_dir + \"/\" + os.path.basename(frame).split(\"_\")[0] + \"*\"\n)\nmatch_images(\nreference_image,\nframe,\ndestination_file,\nnormalization=normalization,\nmask_method=mask_method,\n)\nif manual_shift is not None:\nprint()\nprint(\"manual shift\")\nmanual_wcs_shift(destination_file, manual_shift)\nprint()\n# Add the manual shift to the reference file\nif manual_shift is not None:\nreference_destination = destination_file = glob.glob(\ndestination_dir\n+ \"/\"\n+ os.path.basename(reference_image).split(\"_\")[0]\n+ \"*\"\n)\nmanual_wcs_shift(reference_destination, manual_shift)\n# Step 5: Cleanup\nif cleanup:\nfm.cleanup(temp_dir)\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.align_multiple_filters","title":"<code>align_multiple_filters(image_sets, reference_set_index=0, cleanup=True, matching_config={})</code>","text":"<p>Function for aligning image sets between multiple filters </p> <p>Parameters:</p> Name Type Description Default <code>image_sets</code> <code>list or iterable</code> <p>list of ImageSet instances</p> required <code>reference_set_index</code> <code>int</code> <p>index of the ImageSet in the image_set list that is to be used as reference for cross correlation</p> <code>0</code> <code>cleanup</code> <code>bool</code> <p>whether to cleanup the temporary folders and intermediate drizzling results</p> <code>True</code> <code>matching_config</code> <code>dict</code> <p>keyword arguments that are passed directly to match images</p> <code>{}</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def align_multiple_filters(image_sets, reference_set_index=0, cleanup=True, matching_config={}):\n\"\"\" Function for aligning image sets between multiple filters \n    Parameters\n    ----------\n    image_sets : list or iterable\n        list of ImageSet instances\n    reference_set_index : int\n        index of the ImageSet in the image_set list that is to be used as reference for cross correlation\n    cleanup : bool\n        whether to cleanup the temporary folders and intermediate drizzling results\n    matching_config : dict\n        keyword arguments that are passed directly to match images\n    \"\"\"\nsource_images = []\nfor image_set in image_sets:\nimage_set.drizzle()\nsource_images.append(image_set.drizzled_files)\nreference_image = source_images[reference_set_index]\nfor i, image in source_images:\nif i == reference_set_index:\npass\nelse:\ndra, ddec = match_images(reference_image, image, **matching_config)\nimage_sets[i].backpropagate_wcs_shift(dra, ddec)\nif cleanup:\nimage_set.clean_temp_directories()\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.align_single_filter","title":"<code>align_single_filter(image_set, cleanup=True, matching_config={})</code>","text":"<p>Function for aligning images in a single set</p> <p>Parameters:</p> Name Type Description Default <code>image_set</code> <code>ImageSet instance</code> <p>an ImageSet instance with the relevant files to be aligned</p> required <code>reference_set_index</code> <code>int</code> <p>index of the ImageSet in the image_set list that is to be used as reference for cross correlation</p> required <code>cleanup</code> <code>bool</code> <p>whether to cleanup the temporary folders and intermediate drizzling results</p> <code>True</code> <code>matching_config</code> <code>dict</code> <p>keyword arguments that are passed directly to match images</p> <code>{}</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def align_single_filter(image_set, cleanup=True, matching_config={}):\n\"\"\" Function for aligning images in a single set\n    Parameters\n    ----------\n    image_set : ImageSet instance\n        an ImageSet instance with the relevant files to be aligned\n    reference_set_index : int\n        index of the ImageSet in the image_set list that is to be used as reference for cross correlation\n    cleanup : bool\n        whether to cleanup the temporary folders and intermediate drizzling results\n    matching_config : dict\n        keyword arguments that are passed directly to match images\n    \"\"\"\nimage_set.drizzle(individual=True)\nsource_images = image_set.drizzled_files\nreference_image = source_images[0]\nfor i, image in source_images:\nif i == 0:\npass\nelse:\ndra, ddec = match_images(reference_image, image, **matching_config)\nimage_set.images[i].backpropagate_wcs_shift(dra, ddec)\nif cleanup:\nimage_set.clean_temp_directories()\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.corr2d","title":"<code>corr2d(image_to_shift, refimage)</code>","text":"<p>Function for calculating the x and y shift required for image <code>image_to_shift</code> to be matched to <code>refimage</code></p> <p>Parameters:</p> Name Type Description Default <code>image_to_shift</code> <code>np.ndarray</code> <p>image_array</p> required <code>refimage</code> <code>np.ndarray</code> <p>image_array</p> required <p>Returns:</p> Name Type Description <code>x_shift</code> <code>int</code> <code>y_shift</code> <code>int</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def corr2d(image_to_shift, refimage):\n\"\"\"Function for calculating the x and y shift required for image\n    `image_to_shift` to be matched to `refimage`\n    Parameters\n    ----------\n    image_to_shift : np.ndarray\n        image_array\n    refimage : np.ndarray\n        image_array\n    Returns\n    -------\n    x_shift : int\n    y_shift : int\n    \"\"\"\ncorr = correlate2d(image_to_shift, refimage, mode=\"same\")\nshift = np.where(corr == corr.max())\nshift = (\n-1 * (shift[0] % refimage.shape[0] - refimage.shape[0] / 2 + 1),\n-1 * (shift[1] % refimage.shape[1] - refimage.shape[0] / 2 + 1),\n)\nreturn shift[1][0], shift[0][0]\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.corr2d_sk","title":"<code>corr2d_sk(refima, ima, mask_ref, mask_ima)</code>","text":"<p>Performs (masked) cross correlation with scikit_image</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def corr2d_sk(refima, ima, mask_ref, mask_ima):\n\"\"\"Performs (masked) cross correlation with scikit_image\"\"\"\nshift = phase_cross_correlation(\nrefima, ima, reference_mask=mask_ref, moving_mask=mask_ima\n)\n# shifts are given as {row, col}\nreturn shift[1], shift[0]\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.dpixels_to_dwcs","title":"<code>dpixels_to_dwcs(dx, dy, pixscale_x, pixscale_y, ref_dec)</code>","text":"<p>Converts from pixel shifts to shifts in ra and declination</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def dpixels_to_dwcs(dx, dy, pixscale_x, pixscale_y, ref_dec):\n\"\"\"Converts from pixel shifts to shifts in ra and declination\"\"\"\nd_dec = dy * pixscale_y\nd_ra = dx * pixscale_x * np.cos(np.deg2rad(ref_dec))\nreturn d_ra, d_dec\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.get_image_coords","title":"<code>get_image_coords(header)</code>","text":"<p>Fetches RA and dec from a given header</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def get_image_coords(header):\n\"\"\"Fetches RA and dec from a given header\"\"\"\nreturn header[\"CRVAL1\"], header[\"CRVAL2\"]\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.image_normalization","title":"<code>image_normalization(image, method='range', lower=0, higher=50, mask=None)</code>","text":"<p>Normalizes an np.array</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>input image array</p> required <code>method</code> <p>sets type of normalization. Default \"white\"</p> <p>minmax - subtract minimum value and divide by maximum</p> <p>white - subtract mean divide by standard deviation</p> <p>range - clips image data to range 0 to 100</p> <code>\"white\"</code> <code>mask</code> <code>ndarray(boolean)</code> <p>mask array for input image, valid pixels are True.</p> <p>Default: All pixels valid. NB masked pixels are set to 0 for statistics.</p> <code>None</code> Source code in <code>crocoa/imalign.py</code> <pre><code>def image_normalization(image, method=\"range\", lower=0, higher=50, mask=None):\n\"\"\"Normalizes an np.array\n    Parameters\n    ----------\n    image : ndarray\n        input image array\n    method : {\"white\", \"minmax\", \"range\"}\n        sets type of normalization. Default \"white\"\n        minmax - subtract minimum value and divide by maximum\n        white - subtract mean divide by standard deviation\n        range - clips image data to range 0 to 100\n    mask : ndarray (boolean)\n        mask array for input image, valid pixels are True.\n        Default: All pixels valid. NB masked pixels are set to 0 for statistics.\n    \"\"\"\nif mask is None:\nmask = np.ones(image.shape, dtype=\"bool\")\nimage = np.where(mask, image, 0.0)\nif method is None:\nimg = image\nelif method == \"white\":\nimg = (image - image.mean()) / image.std()\nelif method == \"minmax\":\nimg = (image - image.min()) / image.max()\nelif method == \"range\":\nimg = np.clip(image, lower, higher)\nelif method == \"clip_pixels\":\nsorted_pixels = np.sort(image.flatten())\nlower_range = sorted_pixels[lower]\nhigher_range = sorted_pixels[-higher]\nimg = np.clip(image, lower_range, higher_range)\nelif method == \"percentile\":\nimg = np.clip(image, np.percentile(image, lower), np.percentile(image, higher))\nelse:\nraise ValueError\nreturn img\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.manual_wcs_shift","title":"<code>manual_wcs_shift(image_list, shift_dict)</code>","text":"<p>Function for applying a manual alteration of the WCS Primarily for doing rough alignment before correlation analysis</p> Source code in <code>crocoa/imalign.py</code> <pre><code>def manual_wcs_shift(image_list, shift_dict):\n\"\"\"Function for applying a manual alteration of the WCS\n    Primarily for doing rough alignment before correlation analysis\n    \"\"\"\nfor img in image_list:\nvisit_name = os.path.basename(img).split(\"_\")[0]\nif visit_name in shift_dict.keys():\nfm.write_wcs_to_fits(\nimg, shift_dict[visit_name][\"dra\"], shift_dict[visit_name][\"ddec\"]\n)\nprint(\"Applied manual correction to: \", img)\n</code></pre>"},{"location":"apidocs/#crocoa.imalign.match_images","title":"<code>match_images(reference_fits, image_fits, verbose=True, normalization='white', clip=None, mask_method='zero')</code>","text":"<p>Function that matches the coordinatesystem of image_fits to that of reference_fits by means of cross-correlation</p> <p>Parameters:</p> Name Type Description Default <code>reference_fits</code> <code>str</code> <p>directory of the reference image</p> required <code>image_fits</code> <code>str</code> <p>directory of the image that should be matched</p> required <code>output_fits</code> <code>list</code> <p>path to original flc files where wcs should be updated</p> required Source code in <code>crocoa/imalign.py</code> <pre><code>def match_images(\nreference_fits,\nimage_fits,\nverbose=True,\nnormalization=\"white\",\nclip=None,\nmask_method=\"zero\",\n):\n\"\"\"Function that matches the coordinatesystem of image_fits\n    to that of reference_fits by means of cross-correlation\n    Parameters\n    ----------\n    reference_fits : str\n        directory of the reference image\n    image_fits : str\n        directory of the image that should be matched\n    output_fits : list\n        path to original flc files where wcs should be updated\n    \"\"\"\nif verbose:\nprint(\"ref\", reference_fits)\nprint(\"shift image\", image_fits)\n# 1. Read data\nrefdata = fits.getdata(reference_fits)\nrefheader = fits.getheader(reference_fits)\nshiftdata = fits.getdata(image_fits)\nshiftheader = fits.getheader(image_fits)\n# 1.01 Check if there are nans in data and create masks in that case\n# masks are True on valid pixels\nif np.any(np.isnan(refdata)):\nrefmask = ~np.isnan(refdata)\nelse:\nrefmask = np.ones(refdata.shape, dtype=\"bool\")\nif np.any(np.isnan(shiftdata)):\nshiftmask = ~np.isnan(shiftdata)\nelse:\nshiftmask = np.ones(shiftdata.shape, dtype=\"bool\")\n# 1.1 Normalize data\nif clip is not None:\nshiftdata = image_normalization(\nshiftdata,\nmethod=\"range\",\nlower=0,\nhigher=None,\nmask=shiftmask,\n)\nrefdata = image_normalization(\nrefdata,\nmethod=\"range\",\nlower=0,\nhigher=None,\nmask=refmask,\n)\nshiftdata_n = image_normalization(shiftdata, method=normalization, mask=shiftmask)\nrefdata_n = image_normalization(refdata, method=normalization, mask=refmask)\n# 2. Get cross correlation shifts\nif (np.any(np.isnan(refdata)) | np.any(np.isnan(shiftdata))) &amp; (\nmask_method == \"skimage\"\n):\n# run scikit correlate to deal with masked pixels\nprint(\"Warning: NaN pixels in input data (skimage masked correlation chosen).\")\nxshift, yshift = corr2d_sk(refdata_n, shiftdata_n, refmask, shiftmask)\nelse:\nshiftdata_n = np.where(shiftmask, shiftdata_n, 0.0)\nrefdata_n = np.where(refmask, refdata_n, 0.0)\nxshift, yshift = corr2d(shiftdata_n, refdata_n)\nif verbose:\nprint(\"X shift: \", xshift)\nprint(\"Y shift: \", yshift)\n# 3. Translate into Ra and dec\nxscale, yscale = get_pixel_scale(shiftheader)\nra, dec = get_image_coords(shiftheader)\ndra, ddec = dpixels_to_dwcs(xshift, yshift, xscale, yscale, dec)\nif verbose:\nprint(\"Delta RA: \", dra)\nprint(\"Delta DEC: \", ddec)\nreturn dra, ddec\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Here are some examples of primary use cases for the code</p> <p>The examples here assumes that the flt frames have been pipeline processed and </p>"},{"location":"examples/#aligning-frames-within-a-single-filter","title":"Aligning frames within a single filter","text":"<p>Add the central Ra and Dec to the drizzle configuration </p> <pre><code>from crocoa.drizzle_config import config\nconfig['final_ra'] = 1.12637\nconfig['final_dec'] = -10.19156\n</code></pre> <p>Set up the working directory and create an <code>ImageSet</code></p> <p>Warning</p> <p>This will change the world coordinate systems of the flt files that are given to the ImageSet.  Making copies is always advisable</p> <pre><code>from crocoa.filemanagement import ImageSet\nfrom pathlib import Path\nsource_dir = Path('path/to/flts')\nflt_frames = list(source_dir.glob('*.flt'))\nimg_set = ImageSet(flt_frames, drizzle_config=config)\n</code></pre> <p>Use the align filter function to align the images in the <code>ImageSet</code> <pre><code>from crocoa.imalign import align_single_filter\nalign_single_filter(img_set)\n</code></pre></p>"},{"location":"examples/#aligning-frames-between-several-filters","title":"Aligning frames between several filters","text":"<p>This is done in a very similar manner to aligning a single filter, however the difference is that  we pass several ImageSets as a list rather than a single image set</p> <p>Note</p> <p>This assumes that each individual filter has already been aligned internally according to the process outlined above.</p> <pre><code>from crocoa.filemanagement import ImageSet\nfrom crocoa.imalign import align_multiple_filters\nfrom crocoa.drizzle_config import config\nfrom pathlib import Path\nconfig['final_ra'] = 1.12637\nconfig['final_dec'] = -10.19156\n# Filter 1\nsource_dir = Path('path/to/filter1/flts')\nflt_frames = list(source_dir.glob('*.flt'))\nimg_set1 = ImageSet(flt_frames, drizzle_config=config)\n# Filter 2\nsource_dir = Path('path/to/filter2/flts')\nflt_frames = list(source_dir.glob('*.flt'))\nimg_set2 = ImageSet(flt_frames, drizzle_config=config)\nimg_sets = [img_set1, img_set2]\nalign_multiple_filters(img_sets)\n</code></pre>"},{"location":"examples/#tweaking-configuration","title":"Tweaking configuration","text":"<p>If you want to pass more detailed configurations to the internal steps this is done in 2 ways</p>"},{"location":"examples/#changing-drizzle-configuration-settings","title":"Changing Drizzle configuration settings","text":"<p>The default drizzle configuration settings used in the code are located in <code>crocoa.drizzle_config</code> and are passed as a dictionary</p> <p>If you wish to examine or alter these you can simply import these settings, alter them and pass the new dictionary to the ImageSet constructor when you set it up</p> <pre><code>from crocoa.filemanagement import ImageSet\nfrom crocoa.drizzle_config import config\n# Examine the values in the current config\nfor k in config.keywords():\nprint(k, ': ', config[k])\n# Change one \nconfig[final_scale] = 0.02\n# Then pass it to your image set \n</code></pre>"},{"location":"examples/#changing-image-correlation-settings","title":"Changing image correlation settings","text":"<p>The settings available for the image correlation are the keywords specified for the <code>match_images</code> function</p> <ul> <li><code>verbose=True</code></li> <li><code>normalization=\"white\"</code></li> <li><code>clip=None</code></li> <li><code>mask_method=\"zero\"</code></li> </ul> <p>The verbosity sets the detail of the printout for each matching. When not debugging it can be useful to set this to false to prevent  an enormous amount of terminal output from astro_drizzle</p> <p>The normalization sets what method is used to normalize the images before running the cross correlation. </p> <p>The clip argument sets whether some range of values should be clipped out of the image. </p> <p>The mask method sets what way nan values in the resulting drizzled images should be handled. By default they are just set to zero</p> <p>To change these arguments one passes a dictionary to the align function </p> <pre><code>from crocoa.imalign import align_single_filter\n# Lets use a minmax normalization in the matching \ncrosscorr_config = {'normalization': 'minmax'}\nalign_single_filter(img_set, matching_config=crosscorr_config)\n</code></pre>"}]}